# Proxy
* used to define custom behavior for fundamental operations (e.g. property lookup, assignment, enumeration, function invocation, etc)

## Trap handlers
* has - traps ```in```
* deleteProperty - traps ``` delete```
* defineProperty - traps ``` Object.defineProperty()```
* enumerate - traps ``` for...in```
* ownKeys - traps ``` Object.keys()```
* apply - traps function calls

## 1
```js
let T = {};

let PX = new Proxy(T, {});

PX.name = "proxy";
console.log(PX.name);        // "proxy"
console.log(T.name);       // "proxy"

T.name = "target";
console.log(PX.name);        // "target"
console.log(T.name);       // "target"

```

## 2
```js
let T = {};

let handler = {
get(receiver, name) {
return `Hello, ${name}!`;
}
};

let PX = new Proxy(T, handler);
PX.world === 'Hello, world!';
console.log(PX.world);


```
## 3
```js
let twice = {
    apply(target, ctx, args){
        return Reflect.apply(... arguments) * 2;
    }
}

const sum = (a, b) => a + b;

let PX = new Proxy(sum, twice);

console.log(PX(1,2));
console.log(PX(...[3,4]));
console.log(PX.apply(null, [3, 4]));



```
## Validating properties using set trap
**set Trap** receives 4 args:
* trap target - object, that will recive property
* key - the property key (String / Symbol) to write to
* value - value being written to property
* receiver - the object on which the operation took place
you can assign to name because it EXIST ON TARGET already

```js
let T = {
    name: "target"
}


let PX = new Proxy(T, {
    set(trap, key, value, receiver){
        
        if(!trap.hasOwnProperty(key)){
            if(isNaN(value)){
                throw new TypeError("Must be a number!");
            }
        }
        
        return Reflect.set(trap, key, value, receiver);
    }
});

PX.count = 1;
console.log(PX.count);
console.log(T.count);

PX.name = "PX";
console.log(PX.name);
console.log(T.name);

// PX.another = "PX"; -> ERROR

```


## Hiding property existence
* with ```js handler.has()``` you can hide any property you want
* works with "deleteProperty"

```
let R2 = delete proxy.name;
console.log(R2);               
console.log("name" in proxy);
```

```js
let T = {
    name: "target",
    value: 42
};

let PX = new Proxy(T, {
    has(trapTarget, key) {

        if (key === "value") {
            return false;
        } else {
            return Reflect.has(trapTarget, key);
        }
    }
});


console.log("value" in PX);      // false
console.log("name" in PX);       // true
console.log("toString" in PX);   // true


```


## Proxy.revokable()
```js
let T = {
    name: "target"
};

let { PX, revoke } = Proxy.revocable(T, {});

console.log(PX.name);        // "target"
revoke();

// console.log(PX.name); -> ERROR

```

## Prototype proxy traps


```js

let T = {};
let PX = new Proxy(T, {
    getPrototypeOf(trapT) {
        return null;
    },
    setPrototypeOf(trapT, proto) {
        return false;
    }
});

let TP = Object.getPrototypeOf(T);
let proxyProto = Object.getPrototypeOf(PX);

console.log(TP === Object.prototype);      // true
console.log(proxyProto === Object.prototype);       // false
console.log(proxyProto);                            // null

// succeeds
Object.setPrototypeOf(T, {});
//  Object.setPrototypeOf(PX, {}); -> ERROR
```
