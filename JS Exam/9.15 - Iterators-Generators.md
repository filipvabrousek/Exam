# GENERATORS, ITERATORS

* they break the typical “run to completion” model of normal functions (can start, pause, and reset)
* ```function* generator { … }```
* ```yield``` keyword signals when to ‘pause’ the function and return its current state
* generator is a function that returns an iterator
* yield / next duality is 2 way message passing mechanism  
* ```yield ...``` expression pauses waiting for a value, and the ```next()``` call passes a value (or undefined) back to that paused yield expression   

## Built-in Iterators
* **entries** returns an iterator whose values are a key-value pair
* **keys** returns an iterator whose values are the keys contained in the collection
* **values** returns an iterator whose values are the values of the collection



## 1

```js
function isIterable(object) {
    return typeof object[Symbol.iterator] === "function";
}

console.log(isIterable([1, 2, 3]));     // true
```

## 2
* Show Fibonacci numbers smaller than 100 (1, 2, 3, 5, 8, 13, 21, 34, 55, 89)
```js

let fibonacci = {

    *[Symbol.iterator]() {

        let pre = 0,
            cur = 1;

        for (;;) {
            [pre, cur] = [cur, pre + cur];
            yield cur;
        }
    }
}

for (let n of fibonacci) {
    if (n > 100)
        break;
    console.log(n);
}
```

## 3
```javascript

let greeting = "hello world";
let ita = greeting[Symbol.iterator]();

ita.next(); // { value: "h", done: false }
ita.next(); // { value: "e", done: false }
```

## Entries
```javascript
let m = new Map();
m.set("Filip", 17);
m.set({cool: true});

for (let entry of m.entries()){
    console.log(`Entries: ${entry}`);
}

for (let key of m.keys()){
    console.log(`Keys: ${key}`);
}

for (let value of m.values()){
    console.log(`Values: ${value}`);
}
```


## 4
```javascript

let a = [1, 2, 3, 4, 5];
let itd = a[Symbol.iterator]();

let [x, y] = itd; // take just the first two elements from `it`
let [z, ...w] = itd; // take the third, then the rest all at once

// is `it` fully exhausted? Yep.
itd.next(); // { value: undefined, done: true }

x; // 1
y; // 2
z; // 3
w; // [4,5]
```
## 5

* Overwrite species to the parent Array constructor
* For example, when using methods such as map() that return the default constructor,
* you want these methods to return a parent Array object, instead of the MyArray object.

```javascript
class coolArray extends Array{
    static get[Symbol.species](){
        return Array;
    }
}

var x = new coolArray(1, 2, 3);
var mapped = x.map(x => x*x);
console.log(mapped);

console.log(mapped instanceof coolArray); // false
console.log(mapped instanceof Array);   // true
```

## Passing arguments to an Iterator
```js
function *C(){
    let first = yield 1;
    let second = yield first + 2;
    yield second;
}

let it = C();
console.log(it.next());
console.log(it.next(4)); // Object {value: 6, done: false}

```






## 6
```javascript
function* range(start, end, step) {

    while (start < end) {
        yield start;
        start += step;
    }
}

for (let i of range(0, 10, 2)) {
    console.log(i);
}
```

## 7
```javascript
let collection = {
    items: [],
    *[Symbol.iterator]() {
        for (let item of this.items) {
            yield item;
        }
    }

};

collection.items.push(1);
collection.items.push(2);
collection.items.push(3);

for (let x of collection) {
    console.log(x);
}

```
## 8

```javascript
function* IT(){
    yield* arguments;
}

let ait = IT([1,2,3]);
console.log(ait.next().value);
```

## 9
```js
let x = 1;

function *A(){
    x++;
    yield;
    console.log(x); //2
}

function B(){
    x++;
}

let it = A();
it.next();
console.log(x); //3
B();
console.log(x); //3
it.next();
```
## 10
```js
function* extract(w){
    for (const word of w){
        if(/^[0-9]+$/.test(word)){
            yield Number(word);
        }
    }
}


let a = ['a', 10, 'c', 20];

for (const x of extract(a)){
    console.log(x);
}

// 10, 20


```

## 11

```js


function *ret(){
    yield 1;
    yield 2;
    return 3; // ignored by for-of
}

for (const x of ret()){
    console.log(x);
}

// 1, 2
```



## 12

```js
function *foo() {
	let x = yield 2;
	z++;
	let y = yield (x * z);
	console.log( x, y, z );
}

let z = 1;

let it1 = foo();
let it2 = foo();

let val1 = it1.next().value;			// 2 <-- yield 2
let val2 = it2.next().value;			// 2 <-- yield 2

val1 = it1.next( val2 * 10 ).value;		// 40  <-- x:20,  z:2
val2 = it2.next( val1 * 5 ).value;		// 600 <-- x:200, z:3

it1.next( val2 / 2 );					// y:300
										// 20 300 3
it2.next( val1 / 4 );					// y:10
										// 200 10 3


```
## Runner

```js
function F(a){
    return a*a;
}


function* main(){
    try{
        let text = yield F(8);
        console.log(text);
    } catch(err){
        console.log(err);
    }
}




function run(gen){
    let args = [].slice.call(arguments, 1);
    
    //initialize generator in the current context
    let it = gen.apply(this, args);
    
    
    //---2------------------------------------------
    return Promise.resolve()
    .then(HN = (value) => {
        let next = it.next(value);
        
    //---1------------------------------------------
        return (HR = (next) => {
            
            //generator has completed running
            if(next.done){
                return next.value;
            } 
            
            //resolve, HN and HE
            else {
                return Promise.resolve(next.value)
                .then(
                HN, HE = (err) => {
                        return Promise.resolve(
                        it.throw(err)
                        )
                        .then(HR);
                    }
                ); 
            }
            
        })(next); //--1
        
    }); //--2
}

run(main);




```

