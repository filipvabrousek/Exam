# Runny

# View controller
```swift

import UIKit
import MapKit
import CoreLocation
import CoreData



// variable initializations
var LM = CLLocationManager()
var travelled:Double = 0
var AL = CLLocation(latitude: 0, longitude: 0)
var AL2  = CLLocationCoordinate2D(latitude: 0, longitude: 0)
let date = Date()
let formatter = DateFormatter()
let a = [Double: Double]()
var total = 0.0



class ViewController: UIViewController, CLLocationManagerDelegate, MKMapViewDelegate {
    
    //outlets
    @IBOutlet var timerLabel: UILabel!
    @IBOutlet var distanceLabel: UILabel!
    @IBOutlet var map: MKMapView!
    @IBOutlet var startBtn: UIButton!
    @IBOutlet var finishBtn: UIButton!
    @IBOutlet var sideNav: UIView!
    @IBOutlet var prevLabel: UILabel!
    @IBOutlet var countLabel: UILabel!
    
    //variables
    var timer = Timer()
    var sec = 0
    var minutes = 0
    var startLocation:CLLocation!
    var lastLocation: CLLocation!
    var distanceString = ""
    var secDuration = 0.0
    
    
    // arrays
    lazy var locations = [CLLocation]()
    var myLocations: [CLLocation] = []
    
    
    
    
    
    /*-----------------------------------------------------------VIEW DID LOAD---------------------------------------------------------*/
    override func viewDidLoad() {
        super.viewDidLoad()
        
        sideNav.isHidden = true
        setupManagerAndMap()
        showTotalPreview()
        // proccessCoreData()
        
    }
    
    
    
    @IBAction func show(_ sender: Any) {
        UIView.animate(withDuration: 1) {
           self.sideNav.isHidden = false
        }
    }
    
    @IBAction func hide(_ sender: Any) {
        UIView.animate(withDuration: 1) {
            self.sideNav.isHidden = true
        }
    }
    
    
    func setupManagerAndMap(){
        
        LM.delegate = self
        LM.desiredAccuracy = kCLLocationAccuracyBest
        LM.requestWhenInUseAuthorization()
        map.showsUserLocation = true
        map.mapType = MKMapType.standard
        map.delegate = self
    }
    
  
    
    
    func showTotalPreview()  {
     
        total = 0
        for item in runs{
            total += Double(item.distance)!
        }
        
        total = (total * 100).rounded() / 100
        let count = runs.count
        prevLabel.text = "\(total) km"
        countLabel.text = "\(count) activities"
        
    }
    
    
    /*-----------------------------------------------------------START---------------------------------------------------------*/
    
    @IBAction func startRun(_ sender: Any) {
        
        startBtn.isHidden = true
        timer = Timer.scheduledTimer(timeInterval: 1, target: self, selector: #selector(self.increaseTimer), userInfo: nil, repeats: true)
        LM.startUpdatingLocation()
        
        travelled = 0
        secDuration = 0
    }
    
    
    /*-----------------------------------------------------------FINISH---------------------------------------------------------*/
    
    @IBAction func finishRun(_ sender: Any) {
        stopProccessing()
        getAndSaveData()
    }
    
    func stopProccessing(){
        LM.stopUpdatingLocation()
        timer.invalidate()
    }
    
    func getAndSaveData(){
       
        let dividedDistance = travelled / 1000
        formatter.dateFormat = "dd.MM.yyyy"
        let result = formatter.string(from: date)
        let distS = String(dividedDistance)
        let llat = AL.coordinate.latitude
        let llon = AL.coordinate.longitude
        let dur = Int(secDuration)
        
        // appending to activities - checking if we have some value
        
        if Double(dividedDistance) != 0.000000 && dur != 0{
            
            let run = Run(date: result, distance: distS, lat: llat, lon: llon, duration: dur)
          
            let delegate = UIApplication.shared.delegate as! AppDelegate
            let context = delegate.persistentContainer.viewContext
            let entity = NSEntityDescription.entity(forEntityName: "Activities", in: context)
            let device = NSManagedObject(entity: entity!, insertInto: context)
            
            device.setValue(run, forKey: "runs")
            
            do {
                try context.save()
                distances.append(device)
                print("Saved")
                
            }
            catch{
                print("Sth went wrong \(error)")
            }
            
            
        }
        
       
    }
        
    
     
        
        /*-----------------------------------------------------------TIMER---------------------------------------------------------*/
        @objc func increaseTimer(){
            
            secDuration += 1
            updateTimerUI()
        }
        
        
        func updateTimerUI(){
            if sec < 60{
                sec += 1
                timerLabel.text = String(minutes) + ":" + String(sec)
                
                if sec < 10 && minutes < 10{
                    timerLabel.text = String("0\(minutes):0\(sec)")
                }
                
            } else {
                sec = 0
                minutes += 1
                timerLabel.text = String(minutes) + ":" + String(sec)
                
            }
            
        }
        
        
        /*-----------------------------------------------------------UPDATE LOCATION---------------------------------------------------------
         1 - Show location on the map
         2 - add polyline
         3 - update distance and save location to "locations" array
         */
        
        
        func locationManager(_ manager: CLLocationManager, didUpdateLocations locations: [CLLocation]) {
            
            //  1
            myLocations.append(locations[0])
            
            let location:CLLocation = locations[0]
            let lat = location.coordinate.latitude
            let lon = location.coordinate.longitude
            let latDelta:CLLocationDegrees = 0.05
            let lonDelta:CLLocationDegrees = 0.05
            let span = MKCoordinateSpan(latitudeDelta: latDelta, longitudeDelta: lonDelta)
            
            
            let region = MKCoordinateRegion(center: map.userLocation.coordinate, span: span)
            self.map.setRegion(region, animated: true)
            
            
            //  2
            if (myLocations.count > 1){
                let sourceIndex = myLocations.count - 1
                let destinationIndex = myLocations.count - 2
                
                let c1 = myLocations[sourceIndex].coordinate
                let c2 = myLocations[destinationIndex].coordinate
                var a = [c1, c2]
                let polyline = MKPolyline(coordinates: &a, count: a.count)
                self.map.add(polyline)
            }
            
            
            //3
            for location in locations {
                
                if location.horizontalAccuracy < 20 {
                    if self.locations.count > 0 {
                        travelled += round(location.distance(from: AL))
                    }
                    
                    distanceString = String(round(travelled) / 1000)
                    self.distanceLabel.text = distanceString
                    self.locations.append(location)
                }
            }
            
            AL = CLLocation(latitude: lat, longitude: lon)
            
        }
        
        
        /*---------------------------------------------------------POLYLINE RENDERER-------------------------------------------------------*/
        
        func mapView(_ mapView: MKMapView, rendererFor overlay: MKOverlay) -> MKOverlayRenderer {
            if overlay is MKPolyline{
                
                let gradientColors = [UIColor.green, UIColor.blue, UIColor.yellow, UIColor.red]
                let polylineRenderer = ColorLine(polyline: overlay as! MKPolyline, colors: gradientColors)
                polylineRenderer.strokeColor = UIColor.blue
                polylineRenderer.lineWidth = 4
                return polylineRenderer
            }
            return MKPolylineRenderer()
        }
        
        
        
}


    
 ```
    
    
    




# History View Controller


```swift
import UIKit
import CoreData


var i = 0

// date, distance, duration
var runs = [Run]()


var distances: [NSManagedObject] = []

class HistoryViewController: UIViewController, UITableViewDelegate, UITableViewDataSource {
    
    
    @IBOutlet var tableView: UITableView!
    @IBOutlet var progressBar: UIProgressView!
    @IBOutlet var goalLabel: UILabel!
    @IBOutlet var progressLabel: UILabel!
    
    
    var total:Double = 0.0
    var progressVal = 0
    

    
    
    
    /*-----------------------------------------------------------TABLE VIEW---------------------------------------------------------*/
    
    func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {
        return runs.count
        
    }
    
    func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {
        
        i = indexPath.row
        
        
        let cell = tableView.dequeueReusableCell(withIdentifier: "Cell", for: indexPath) as! ActivityTableViewCell
        cell.updateUI()
        
        return cell
        
    }
    
    func tableView(_ tableView: UITableView, commit editingStyle: UITableViewCellEditingStyle, forRowAt indexPath: IndexPath) {
        

        if editingStyle == UITableViewCellEditingStyle.delete{
          
            print("tried to delete")
        }
    }
    
    
    func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) {
        i = indexPath.row
        performSegue(withIdentifier: "toActivityDetail", sender: nil)
    }
    
    
    override func viewDidLoad() {
        super.viewDidLoad()
        
    }
    
    
    
    
    /*-----------------------------------------------------------VIEW DID APPEAR---------------------------------------------------------
     */
    override func viewDidAppear(_ animated: Bool) {
    fetchArrayFromCoreData()
    tableView.reloadData()
    updateAndSaveProgress()
    }
    
    
  
    
    
    func fetchArrayFromCoreData()  {
        runs.removeAll()
        
        let delegate = UIApplication.shared.delegate as! AppDelegate
        let context = delegate.persistentContainer.viewContext
        
        let request = NSFetchRequest<NSFetchRequestResult>(entityName: "Activities")
        request.returnsObjectsAsFaults = false
        
        do {
            let results = try context.fetch(request)
            
            if results.count > 0 {
                for res in results as! [NSManagedObject]{
                    
                    if let run = res.value(forKey: "runs") as? Run {
                        runs.append(run)
                     //print(runs)
                    }
                    
                }
 
                
            }
 
        }
            
        catch {
            print("Error")
        }
    }
    
    
    func updateAndSaveProgress(){
        var deserveReward = false
        UserDefaults.standard.set(deserveReward, forKey: "REWARD")
    }
    
    
    
   
    
}



```




# Activity View Controller

```swift



import UIKit
import MapKit
import CoreLocation



class ActivityViewController: UIViewController, MKMapViewDelegate, CLLocationManagerDelegate {
    
    
    // variables - 3
    @IBOutlet var dateLabel: UILabel!
    @IBOutlet var distanceLabel: UILabel!
    @IBOutlet var locationLabel: UILabel!
    @IBOutlet var durationLabel: UILabel!
    @IBOutlet var paceLabel: UILabel!
    @IBOutlet var map: MKMapView!
    
    var total = 0.0
    
    
    
    
    
    
    /*-----------------------------------------------------------VIEW DID LOAD---------------------------------------------------------
     1 - decode runs
     2 - add date and distance
     3 - display duration
     4 - get pace
     5 - dipsplay location on map
     6 - get location title
     7 - count total ran km's
     */
    
    
    override func viewDidLoad() {
        super.viewDidLoad()
        updateUI()
    }
    
    
    
    
    func updateUI(){
        //  2
        dateLabel.text = runs[i].date
        distanceLabel.text = runs[i].distance
        
        //  3
        let sec  = Int(runs[i].duration)
        let timeObj = Time(seconds: sec)
        let time = timeObj.createTime
        durationLabel.text = String(time)
        
        // 4
        let paceObj = Pace(seconds: sec, minutes: sec / 60, distance: Double(runs[i].distance)!)
        paceLabel.text = paceObj.createPace
        
        // 5
        updateMap()
      
    }
    
    
    
    
  
    
    
    
    
    func updateMap(){
        
        let deg1 = CLLocationDegrees(runs[i].lat)
        let deg2 = CLLocationDegrees(runs[i].lon)
        let loc = CLLocationCoordinate2D(latitude: deg1, longitude: deg2)
        
        
        let span = MKCoordinateSpan(latitudeDelta: 0.05, longitudeDelta: 0.05)
        let region = MKCoordinateRegion(center: loc, span: span)
        self.map.setRegion(region, animated: true)
        
        let geoLoc = CLLocation(latitude: deg1, longitude: deg2)
        
        var title = ""
        
        CLGeocoder().reverseGeocodeLocation(geoLoc , completionHandler: { (placemarks, error) in
            
            if error != nil {
                // print(error ?? "Something went wrong")
            } else {
                
                if let placemark = placemarks?[0]{
                    if placemark.subThoroughfare != nil{
                        title += placemark.subThoroughfare! + " "
                        
                    }
                    
                    if placemark.thoroughfare != nil {
                        title += placemark.thoroughfare!
                    }
                }
                
            }
            
            
            if title == "" {
                title = "Unknown adress"
            }
            
            self.locationLabel.text = title
        });
 
        print("tried to update")
    }
    
    
    /*--------------------------------------SHARE--------------------------------------*/
    @IBAction func share(_ sender: Any) {
        
        let item = "I ran \(runs[i].distance) km with app Runny"
        let share = UIActivityViewController(activityItems: [item], applicationActivities: nil)
        present(share, animated: true, completion: nil)
    }
    
    
    
    
}










```

# ActivityTableViewCell

```swift
//
//  ActivityTableViewCell.swift
//  Runny
//
//  Created by Filip Vabroušek on 25.08.17.
//  Copyright © 2017 Filip Vabroušek. All rights reserved.
//

import UIKit

class ActivityTableViewCell: UITableViewCell {
    
    
    @IBOutlet var imgView: UIImageView!
    @IBOutlet var distanceLabel: UILabel!
    @IBOutlet var durationLabel: UILabel!
    @IBOutlet var dateLabel: UILabel!
    

    
    override func awakeFromNib() {
        super.awakeFromNib()
    }
    
    
    func updateUI(){
       
        self.dateLabel.text = runs[i].date
        self.distanceLabel.text = runs[i].distance
        self.durationLabel.text = String(runs[i].duration)
        self.imgView.image = UIImage(named: "runner.jpg")
    }
    
    override func setSelected(_ selected: Bool, animated: Bool) {
        super.setSelected(selected, animated: animated)
        
    }
    
}


```

# Totals VC

```swift
import UIKit
import CoreData

class TotalsViewController: UIViewController {

    @IBOutlet var goalLabel: UILabel!
    @IBOutlet var progressBar: UIProgressView!
    @IBOutlet var progressLabel: UILabel!
    
    var total:Double = 0.0
    var progressVal = 0
    
    override func viewDidLoad() {
        super.viewDidLoad()
        goalLabel.alpha = 0
        updateProgress()
    }

   
    
    func updateProgress(){
    
        
        for item in runs{
            total += Double(item.distance)!
        }
        var rounded = (total * 100).rounded() / 100
        
        var progressVal = total / 100.0
        progressBar.setProgress(Float(progressVal), animated: false)
        progressLabel.text = String("\(rounded) / 100 km (\(rounded) %)")
        
        if (progressVal * 100) > 100{
            progressBar.progressTintColor = UIColor.green
            animateLabels()
        }

    }
    
    func animateLabels(){
        UIView.animate(withDuration: 1, animations: {
            self.goalLabel.alpha = 1
            self.goalLabel.isHighlighted = true
            self.progressLabel.alpha = 0
        })
    }

    @IBAction func deleteData(_ sender: Any) {
       deleteData()
    }
    
    
    
    func deleteData(){
        
        let alert = UIAlertController(title: "Delete all data", message: "Are you sure you want to delete all runs?", preferredStyle: .alert)
      
        
        let delete = UIAlertAction(title: "Delete", style: .destructive) { (action) in
            let delegate = UIApplication.shared.delegate as! AppDelegate
            let context = delegate.persistentContainer.viewContext
            
            let request = NSFetchRequest<NSFetchRequestResult>(entityName: "Activities")
            request.returnsObjectsAsFaults = false
            
            let deleteRequest = NSBatchDeleteRequest(fetchRequest: request)
            
            
            do {
                try context.execute(deleteRequest)
                try context.save()
                print("Deleted")
            }
                
            catch {
                print("Deletion failed")
            }
            self.total = 0
            
        }
        
        let cancel = UIAlertAction(title: "Cancel", style: .cancel, handler: { (action) in
            self.dismiss(animated: true, completion: nil)
        })
        
        alert.addAction(delete)
        alert.addAction(cancel)
        present(alert, animated: true, completion: nil)
       
    }
}




```
# Run.swift

```swift

//
//  Run.swift
//  Runny
//
//  Created by Filip Vabroušek on 09.08.17.
//  Copyright © 2017 Filip Vabroušek. All rights reserved.
//

import Foundation

/*------------------------------------------------------RUN---------------------------------------------------------------*/
class Run: NSObject, NSCoding {
    
    
    // HAS TO BE A STRING !!
    struct Keys {
        
        static let date = "date"
        static let distance = "distance"
        static let lat = "lat"
        static let lon = "lon"
        static let duration = "duration" // in seconds
        
    }
    
    
    
    
    private var _date = ""
    private var _distance = ""
    private var _lat = 0.0
    private var _lon = 0.0
    private var _duration = 0 // in seconds
    
    
    
    override init() {}
    
    
    /*---------------------------------------------------------------------------------------------------------*/
    init(date: String, distance: String, lat:Double, lon:Double, duration: Int) {
        
        self._date = date
        self._distance = distance
        self._lat = lat
        self._lon = lon
        self._duration = duration
        
    }
    
    
    
    required init(coder aDecoder:NSCoder){
        
        if let dataObject = aDecoder.decodeObject(forKey: Keys.date) as? String{
            _date = dataObject
        }
        
        if let dataObject2 = aDecoder.decodeObject(forKey: Keys.distance) as? String {
            _distance = dataObject2
        }
        
        if let latObject = aDecoder.decodeDouble(forKey: Keys.lat) as? Double {
            _lat = latObject
        }
        
        if let lonObject = aDecoder.decodeDouble(forKey: Keys.lon) as? Double {
            _lon = lonObject
        }
        
        if let durationObject = aDecoder.decodeInteger(forKey: Keys.duration) as? Int {
            _duration = durationObject
        }
    }
    
    
    
    
    
    func encode(with aCoder: NSCoder) {
        
        aCoder.encode(_date, forKey: Keys.date)
        aCoder.encode(_distance, forKey: Keys.distance)
        aCoder.encode(_lat, forKey: Keys.lat)
        aCoder.encode(_lon, forKey: Keys.lon)
        aCoder.encode(_duration, forKey: Keys.duration)
    }
    
    
    var date: String {
        get {
            return _date
        }
        
        set{
            _date = newValue
        }
    }
    
    var distance: String {
        get {
            return _distance
        }
        
        set {
            _distance = newValue
        }
    }
    
    
    var lat: Double{
        get{
            return _lat
        }
        
        set{
            _lat = newValue
        }
    }
    
    
    var lon: Double{
        get{
            return _lon
        }
        
        set{
            _lon = newValue
        }
    }
    
    var duration: Int {
        get {
            return _duration
        }
        
        set{
            _duration = newValue
        }
    }
    
    
}











/*------------------------------------------------------TIME---------------------------------------------------------------*/
class Time: NSObject, NSCoding {
    
    // HAS TO BE A STRING !!
    struct Keys {
        static let seconds = "seconds"
    }
    
    private var _seconds = 0
    override init() {}
    
    
    /*---------------------------------------------------------------------------------------------------------*/
    init(seconds: Int) {
        self._seconds = seconds
    }
    
    
    
    required init(coder aDecoder:NSCoder){
        
        
        if let secObject = aDecoder.decodeInteger(forKey: Keys.seconds) as? Int{
            _seconds = secObject
        }
    }
    
    
    
    
    
    func encode(with aCoder: NSCoder) {
        aCoder.encode(_seconds, forKey: Keys.seconds)
    }
    
    
    var seconds: Int {
        get {
            return _seconds
        }
        
        set{
            _seconds = newValue
        }
    }
    
    var createTime:String{
        let time =  (_seconds / 3600, (_seconds % 3600) / 60, _seconds % 60)
        let (h, m, s) = time
        
        
        var strHr = String(h)
        var strMin = String(m)
        var strSec = String(s)
        
        if h < 10 {
            strHr = "0\(h)"
        }
        
        if m < 10{
            strMin = "0\(m)"
        }
        
        if s < 10{
            strSec = "0\(s)"
        }
        
        
        
        
        return "\(strHr):\(strMin):\(strSec)"
    }
    
    
    
    
}









/*------------------------------------------------------PACE---------------------------------------------------------------*/
class Pace: NSObject, NSCoding {
    
    // HAS TO BE A STRING !!
    struct Keys {
        static let seconds = "seconds"
        static let minutes = "minutes"
        static let distance = "distance"
    }
    
    private var _seconds = 0
    private var _minutes = 0
    private var _distance = 0.0
    
    
    override init() {}
    
    
    /*---------------------------------------------------------------------------------------------------------*/
    init(seconds: Int, minutes: Int, distance: Double) {
        self._seconds = seconds
        self._minutes = minutes
        self._distance = distance
    }
    
    
    
    required init(coder aDecoder:NSCoder){
        
        
        if let secObject = aDecoder.decodeInteger(forKey: Keys.seconds) as? Int{
            _seconds = secObject
        }
        
        if let minObject = aDecoder.decodeInteger(forKey: Keys.minutes) as? Int{
            _minutes = minObject
        }
        
        if let distObject = aDecoder.decodeDouble(forKey: Keys.distance) as? Double{
            _distance = distObject
        }
    }
    
    
    
    
    
    func encode(with aCoder: NSCoder) {
        aCoder.encode(_seconds, forKey: Keys.seconds)
        aCoder.encode(_minutes, forKey: Keys.minutes)
        aCoder.encode(_distance, forKey: Keys.distance)
    }
    
    
    var seconds: Int {
        get {
            return _seconds
        }
        
        set{
            _seconds = newValue
        }
    }
    
    var minutes: Int {
        get {
            return _minutes
        }
        
        set{
            _minutes = newValue
        }
    }
    
    var distance: Double {
        get {
            return _distance
        }
        
        set{
            _distance = newValue
        }
    }
    
    
    var createPace:String{
        let pace = Double(_minutes * 60 + _seconds) / _distance
        let mins = pace / 60
        let roundedMins = Double(floor(mins))
        let decimalSec = mins - roundedMins
        let intPace = Int(floor(roundedMins))
        let seconds = Int(floor(decimalSec * 60))
        var strSec = String(seconds)
        
        
        
        if seconds < 10 {
            strSec = "0\(seconds)"
        }
        
        
        
        return "\(intPace):\(strSec)"
    }
    
}




class Progress: NSObject, NSCoding {
    
    // HAS TO BE A STRING !!
    struct Keys {
        static let total = "total"
      
    }
    
    private var _total = 0.0
    
    override init() {}
    
    
    /*---------------------------------------------------------------------------------------------------------*/
    init(total:Double) {
        self._total = total
    }
    
    
    
    required init(coder aDecoder:NSCoder){
        if let totalObject = aDecoder.decodeDouble(forKey: Keys.total) as? Double{
            _total = totalObject
        }
    }
    
    
    
    
    
    func encode(with aCoder: NSCoder) {
        aCoder.encode(_total, forKey: Keys.total)
       
    }
    
    
    var total: Double {
        get {
            return _total
        }
        
        set{
            _total = newValue
        }
    }
    
    
    func get(d: Double) -> Float{
        total += d
        let progressTotal = Float(total / 100) //1 km will be 0.01 :  10 will be 0.1
        return progressTotal
    }

}

```



# colorline.swift
* 1 - create a gradient
* 2 - define path properties
* 3 - replace path with stroked version, so we can clip
* 4 - create bounding box
* 5 - draw gradient in the clipped context of the path

```swift

 import MapKit
 
 class ColorLine: MKOverlayPathRenderer {
    
    // variables - 5
    var polyline : MKPolyline
    var colors:[UIColor]
    var border: Bool = false
    var borderColor: UIColor?
    
    
    fileprivate var cgColors:[CGColor]{
        return colors.map({(color) -> CGColor in
            return color.cgColor
        })
    }
    
    
    
    /*------------------------------------------------------------------------------------------------------------------------*/
    init(polyline:MKPolyline, colors: [UIColor]){
        self.polyline = polyline
        self.colors = colors
        super.init(overlay:polyline)
    }
    
    
    
    
    /*---------------------------------------------------------DRAW--------------------------------------------------------------
     
     1 - create a gradient
     2 - define path properties
     3 - replace path with stroked version, so we can clip
     4 - create bounding box
     5 - draw gradient in the clipped context of the path
     
     */
    
    override func draw(_ mapRect: MKMapRect, zoomScale: MKZoomScale, in context: CGContext) {
        
        
        let baseWidth: CGFloat = self.lineWidth / zoomScale
        let colorSpace = CGColorSpaceCreateDeviceRGB()
        let stopValues = calculateNumberOfStops()
        let locations:[CGFloat] = stopValues
        let gradient = CGGradient(colorsSpace: colorSpace, colors: cgColors as CFArray, locations: locations)
        
        
        if self.border{
            context.setLineWidth(baseWidth * 2)
            context.setLineJoin(CGLineJoin.round)
            context.setLineCap(CGLineCap.round)
            context.addPath(self.path)
            context.setStrokeColor(self.borderColor?.cgColor ?? UIColor.white.cgColor)
            context.strokePath()
        }
        
        
        //  2
        context.setLineWidth(baseWidth)
        context.setLineJoin(CGLineJoin.round)
        context.setLineCap(CGLineCap.round)
        context.addPath(self.path)
        
        
        //  3
        context.saveGState()
        context.replacePathWithStrokedPath()
        context.clip()
        
        //  4
        let boundingBox = self.path.boundingBoxOfPath
        let gradientStart = boundingBox.origin
        let gradientEnd = CGPoint(x: boundingBox.maxX, y: boundingBox.maxY)
        
        // 5
        if let gradient = gradient {
            context.drawLinearGradient(gradient, start: gradientStart, end: gradientEnd, options: CGGradientDrawingOptions.drawsBeforeStartLocation)
        }
        
        context.restoreGState()
        super.draw(mapRect, zoomScale: zoomScale, in: context)
    }
    
    
    
    
    
    /*-------------------------------------------------------CREATE PATH FROM POLYLINE------------------------------------------------------*/
    
    override func createPath() {
        let path: CGMutablePath = CGMutablePath()
        var pathIsEmpty:Bool = true
        
        
        for i in 0...self.polyline.pointCount - 1 {
            
            let point:CGPoint = self.point(for: self.polyline.points()[i])
            if pathIsEmpty{
                path.move(to: point)
                pathIsEmpty = false
            } else {
                path.addLine(to: point)
            }
        }
        self.path = path
    }
    
    
    
    /*-------------------------------------------------------CALCULATE NUMBER OF STOPS------------------------------------------------------*/
    fileprivate func calculateNumberOfStops() -> [CGFloat]{
        let stopDifference = (1 / Double(cgColors.count))
        
        return Array(stride(from: 0, to: 1+stopDifference, by: stopDifference))
            .map { (value) -> CGFloat in
                return CGFloat(value)
        }
        
    }
    
 }
 
 

 

```
