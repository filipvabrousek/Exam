# SYMBOLS

* values that programs can create and use as property keys without risking name collisions
*  Symbol.for(string) - this accesses a set of existing symbols called the symbol registry 
* symbols in the symbol registry are shared
* not always unique if you call Symbol.for("cat") thirty times, it will return the same symbol each time

# 1
```javascript
let sym = Symbol("text");
let sym2 = Symbol("text");
console.log(sym === sym2); //false
sym.toString() //works ("Text " + sym => error)
```

# 2
```javascript
class S {
    constructor(value) {
        this.value = value;
    }
    [Symbol.search](string) {
        return string.indexOf(this.value);
    }
}

let a = 'foobar'.search(new S('bar'));
console.log(a); //  3
```


# 3
```javascript
Array.prototype.map = function(cb) {
    const Species = this.constructor[Symbol.species];
    const val = new Species(this.length);
    
    this.forEach((item, index, array) => {
        val[index] = cb(item, index, array);
    });
    
    return val;
}
```


# 4
```javascript
let uid = Symbol.for("uid");
let object = {};

object[uid] = "12345";

console.log(object[uid]);       // "12345"
console.log(uid);               // "Symbol(uid)"


obj instanceof Array;
Array[Symbol.hasInstance](obj);


```






# 5
```javascript
class TM {
	constructor(deg) {
		this.deg = deg;
	}

	[Symbol.toPrimitive](hint) {
		switch (hint) {
			case "string":
				return this.deg + "\u00b0";

			case "number":
				return this.deg;

			default:
				return this.deg + " deg";
		}
	}
}


let freezing = new TM(32);
console.log(freezing + "!");
console.log(freezing / 2);
console.log(String(freezing));
```
