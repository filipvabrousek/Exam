# Proxy
* used to define custom behavior for fundamental operations (e.g. property lookup, assignment, enumeration, function invocation, etc)

## Trap handlers
* has - traps ```in```
* get
* set
* deleteProperty - traps ``` delete```
* defineProperty - traps ``` Object.defineProperty()```
* enumerate - traps ``` for...in```
* ownKeys - traps ``` Object.keys()```
* apply - traps function calls
* construct
* getOwnPropertyDescriptor
* getPrototypeOf
* setPrototypeOf
* preventExtensions
* isExtensible



## 1
```js

const obj = {
    get(target, name){
        return name in target ? target[name] : "doesnt exist";
    }
};

const P = new Proxy({}, obj);
P.a = 1;
console.log(P.a);
console.log("c" in P, P.c);

```

## 2

```js
let T = {};

let PX = new Proxy(T, {});

PX.name = "proxy";
console.log(PX.name);        // "proxy"
console.log(T.name);       // "proxy"

T.name = "target";
console.log(PX.name);        // "target"
console.log(T.name);       // "target"


```
## 3
```js
let twice = {
    apply(target, ctx, args){
        return Reflect.apply(... arguments) * 2;
    }
}

const sum = (a, b) => a + b;

let PX = new Proxy(sum, twice);

console.log(PX(1,2));
console.log(PX(...[3,4]));
console.log(PX.apply(null, [3, 4]));



```
## Validating properties using set trap
**set Trap** receives 4 args:
* trap target - object, that will recive property
* key - the property key (String / Symbol) to write to
* value - value being written to property
* receiver - the object on which the operation took place
you can assign to name because it EXIST ON TARGET already

```js
let T = {
    name: "Filip"
}


let PX = new Proxy(T, {
   set(TR, K, V, R){
       
       if(!TR.hasOwnProperty(K)){
           if (isNaN(V)){
               throw Error("Not a number");
           } 
       }
       
       Reflect.set(TR, K, V, R);
   } 
});



PX.count = 1;
console.log(PX.count);
// PX.n = "Text"; // -> Error

```


## Hiding property existence
* with ```js handler.has()``` you can hide any property you want
* works with "deleteProperty"

```
let R2 = delete proxy.name;
console.log(R2);               
console.log("name" in proxy);
```

```js
let T = {
    name: "target",
    value: 42
};

let PX = new Proxy(T, {
    has(trap, key) {

        if (key === "value") {
            return false;
        } else {
            return Reflect.has(trap, key);
        }
    }
});


console.log("value" in PX);      // false
console.log("name" in PX);       // true
console.log("toString" in PX);   // true
```


## Proxy.revokable()
```js
let T = {
    name: "target"
};

let { proxy, revoke } = Proxy.revocable(T, {});

console.log(proxy.name);        // "target"
revoke();

// console.log(proxy.name); -> ERROR


```

## Prototype proxy traps


```js

let T = {};
let PX = new Proxy(T, {
    getPrototypeOf(trapT) {
        return null;
    },
    setPrototypeOf(trapT, proto) {
        return false;
    }
});

let TP = Object.getPrototypeOf(T);
let proxyProto = Object.getPrototypeOf(PX);

console.log(TP === Object.prototype);      // true
console.log(proxyProto === Object.prototype);       // false
console.log(proxyProto);                            // null

// succeeds
Object.setPrototypeOf(T, {});
//  Object.setPrototypeOf(PX, {}); -> ERROR
```

## Another example

```js
let T = {
    a: 1,
    foo(){
        console.log("a:", this.a);
    }
};

let handlers = {
    
    get(TR, K, C){
    
    if(Reflect.has(TR, K)){
        return Reflect.get(TR, K, C);
    
        
    } else {
    throw "Doesn't exist";
    }
},
    

    set(TR, K, V, C){
        if(Reflect.has(TR, K)){
            return Reflect.set(TR, K, V, C);
        } else {
            throw "Doesn`t exist";
        }
      }

};


let PX = new Proxy(T, handlers);
PX.a = 100;
PX.foo();
```
