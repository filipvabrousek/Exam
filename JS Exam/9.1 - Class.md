# CLASS
* syntactical sugar over existing prototype-based inheritance
* **first-class citizen** - sth that can be can be used as a value, can be passed into a function, returned assigned to a variable
* "special functions"
* function declarations ARE hoisted and class declarations ARE NOT
* **static** properties ARE NOT inherited

# Reports
```js

class E {
    constructor(name) {
        this.name = name;
    }
}

class Park extends E {
    constructor(name, area = 2) {
        super(name);
        this.area = area;
    }

    classify() {
        const m = new Map();
        m.set(1, "tiny");
        m.set(2, "medium");
        m.set(3, "huge");
        console.log(`${this.name} is a ${m.get(this.area)} park`);
    }
}


const parks = [
    new Park("Central park", 1),
    new Park("City park", 3)
];



function calc(arr) {
    const sum = arr.reduce((prev, cur, index) => prev + cur, 0);
    return [sum, sum / arr.length];
}


function report(p) {
    const [totalArea, avgArea] = calc(p.map(el => el.area));
    console.log(`Average area of our ${p.length} parks is ${avgArea}`);
    p.forEach(el => el.classify());

    const i = p.map(el => el.area).findIndex(el => el >= 3);
    console.log(`${p[i].name} is bigger than 2 km2`);
}


report(parks);
 ```


# Extending arrays
```javascript

class Stack extends Array{
   constructor(length){
      super(length);
   }

   top(){
      return this[this.length - 1];
   }
}
    

var s = new Stack();   

s.push("world");
s.push("hello");
console.log(s.top());  // "hello"
console.log(s.length); // 2
   ```
   
 # Empty constructor
   ```javascript
class Parent {
    constructor() {
        if (new.target === Parent) {
            console.log("Parent instantiated");
        } else {
            console.log("A child instantiated");
        }
    }
}

class Child extends Parent {}

var a = new Parent();
// Parent instantiated

var b = new Child();
// A child instantiated
```

# New.target
```js


class R {
    constructor(length, width) {
        console.log(new.target === R);
        this.length = length;
        this.width = width;
    }
}

class S extends R {
    constructor(length) {
        super(length, length)
    }
}

// new.target is Square
var obj = new S(3);      // outputs false
```


# Set
```javascript
let language = {
  set curr(name) {
    this.log.push(name);
  },
  log: []
};

language.curr = "EN";
console.log(language.log); // ['EN']

```



# new class

```javascript
let person = new class {

    constructor(name) {
        this.name = name;
    }

    sayName() {
        console.log(this.name);
    }

}("Filip");

person.sayName();  
```
# Computed names
```javascript
let mName = "say";

class P {

    constructor(name) {
        this.name = name;
    }

    [mName]() {
        console.log(this.name);
    }
}

let me = new P("Filip");
me.say();    
```


# Clonning
```js
class S {
    static get [Symbol.species]() {
        return this;
    }

    constructor(value) {
        this.value = value;
    }

    clone() {
        return new this.constructor[Symbol.species](this.value);
    }
}

class MD1 extends S {
    // empty
}

class MD2 extends S {
    static get [Symbol.species]() {
        return S;
    }
}

let inst1 = new MD1("foo"),
    clone1 = inst1.clone(),
    inst2 = new MD2("bar"),
    clone2 = inst2.clone();

console.log(clone1 instanceof S);             // true
console.log(clone1 instanceof MD1);     // true
console.log(clone2 instanceof S);             // true
console.log(clone2 instanceof MD2);     // false


```

# ES5 Inheritance


```
function Person(name, born){
    this.name = name;
    this.born = born;
}

Person.prototype.age = function(){
    console.log(2017 - this.born);
}

var me = new Person("Filip", 1999);
me.age();

var terka = Object.create(me);
terka.name = "Terka";
terka.born = 2000;
terka.age();
```
