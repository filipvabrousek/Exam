# CLASS
* syntactical sugar over existing prototype-based inheritance
* **first-class citizen** - sth that can be can be used as a value, can be passed into a function, returned assigned to a variable
* "special functions"
* function declarations ARE hoisted and class declarations ARE NOT
* **static** assigned to the function NOT ITS PROTOTYPE!!! (not inherited)
* not methods of instance, but of the whole classes


* you do not have to use the constructor (its the same as empty one ```constructor(){}```)
* all code inside a class runs in a **strict mode**


# Reports
```js

class E {
    constructor(name) {
        this.name = name;
    }
}

class Park extends E {
    constructor(name, area = 2) {
        super(name);
        this.area = area;
    }

    classify() {
        const m = new Map();
        m.set(1, "tiny");
        m.set(2, "medium");
        m.set(3, "huge");
        console.log(`${this.name} is a ${m.get(this.area)} park`);
    }
}


const parks = [
    new Park("Central park", 1),
    new Park("City park", 3)
];



function calc(arr) {
    const sum = arr.reduce((prev, cur, index) => prev + cur, 0);
    return [sum, sum / arr.length];
}


function report(p) {
    const [totalArea, avgArea] = calc(p.map(el => el.area));
    console.log(`Average area of our ${p.length} parks is ${avgArea}`);
    p.forEach(el => el.classify());

    const i = p.map(el => el.area).findIndex(el => el >= 3);
    console.log(`${p[i].name} is bigger than 2 km2`);
}


report(parks);

console.log(Park === Park.prototype.constructor); // TRUE
console.log(Object.getOwnPropertyNames(Park.prototype)); // ["constructor", "classify"]
 ```


# Getters and setters

```js
class P{
    constructor(name){
        this.name = name;
    }
    
    get name(){
        return this._name;
    }
    
    set name(value){
        this._name = value;
        console.log("Name was changed!")
    }
}

let me = new P("Filip");
me = new P("Terka");
console.log(me.name); // Terka
```
* internally...
```
Object.defineProperties(P.prototype, {
    name:{
        get().......
    }
    ...
})
```

# You can extend data types
* make more simple!!!
```javascript

class Stack extends Array{
   constructor(length){
      super(length);
   }

   top(){
      return this[this.length - 1];
   }
}
    

var s = new Stack();   

s.push("world");
s.push("hello");
console.log(s.top());  // "hello"
console.log(s.length); // 2
   ```
   
 # Empty constructor
   ```javascript
class Parent {
    constructor() {
        if (new.target === Parent) {
            console.log("Parent instantiated");
        } else {
            console.log("A child instantiated");
        }
    }
}

class Child extends Parent {}

var a = new Parent();
// Parent instantiated

var b = new Child();
// A child instantiated
```





# Class creation
```javascript
function create(text){
    return class {
        say(){
             console.log(text);
        }
       
    }
}

let x = create("Hi");
new x().say(); // Hi
```



# Computed names
```javascript
let mName = "say";

class P {

    constructor(name) {
        this.name = name;
    }

    [mName]() {
        console.log(this.name);
    }
}

let me = new P("Filip");
me.say();    
```

# New.target
```js


class R {
    constructor(length, width) {
        console.log(new.target === R);
        this.length = length;
        this.width = width;
    }
}

class S extends R {
    constructor(length) {
        super(length, length)
    }
}

// new.target is Square
var obj = new S(3);      // outputs false
```


# Clonning
```js
class S {
    static get [Symbol.species]() {
        return this;
    }

    constructor(value) {
        this.value = value;
    }

    clone() {
        return new this.constructor[Symbol.species](this.value);
    }
}

class MD1 extends S {
    // empty
}

class MD2 extends S {
    static get [Symbol.species]() {
        return S;
    }
}

let inst1 = new MD1("foo"),
    clone1 = inst1.clone(),
    inst2 = new MD2("bar"),
    clone2 = inst2.clone();

console.log(clone1 instanceof S);             // true
console.log(clone1 instanceof MD1);     // true
console.log(clone2 instanceof S);             // true
console.log(clone2 instanceof MD2);     // false


```

# ES5 Inheritance


```
function Person(name, born){
    this.name = name;
    this.born = born;
}

Person.prototype.age = function(){
    console.log(2017 - this.born);
}

var me = new Person("Filip", 1999);
me.age();

var terka = Object.create(me);
terka.name = "Terka";
terka.born = 2000;
terka.age();
```
